norm(sample$theta[,2])
theta
sample$theta
names(sample)
logLMatriz(20*sample$theta,omega)
logLMatriz(200*sample$theta,omega)
logLMatriz(10*sample$theta,omega)
logLMatriz(0.03*sample$theta,omega)
logLMatriz(7.25*sample$theta,omega)
n=10000
sample = geraPolinomios(n, omega)
Ldiri = logLMatriz(sample$theta,omega)
Ldiri
max(Ldiri)
?compositions
library(compositions)
?compositions
?legend
X = cbind(1:12, 2:13, 3:14)
cores = c('red', 'darkgreen', 'blue')
plot(1:12, X[,1], xlab='mes', ylab='faturamento', type='b', col=cores[1])
lines(1:12, X[,2], col=cores[2])
lines(1:12, X[,3], col=cores[3])
legend(right, 2010:2012, col=cores)
legend(right, legend=2010:2012, col=cores)
legend('right', legend=2010:2012, col=cores)
?points
X = cbind(1:12, 2:13, 3:14)
cores = c('red', 'darkgreen', 'blue')
plot(1:12, X[,1], xlab='mes', ylab='faturamento', type='b', col=cores[1], lwd=3)
points(1:12, X[,2], type='b', col=cores[2], lwd=3)
points(1:12, X[,3], type='b', col=cores[3], lwd=3)
legend('right', legend=2010:2012, col=cores, lwd=3)
install.packages("party")
library(party)
??party
?ctree
?factor_trafo
?f_trafo
?id_trafo
?ctree
for (i in 1:10) {
x = (30 - i*0.5)/3
print(c(i,x))
}
for (i in 0:9) {
x = (30 - i*0.5)/3
print(c(i,x))
}
for (i in 0:9) {
x = (30 - i*0.5)/3
print(c(i*0.5,x))
}
?scan
setwd("E:/each/disciplinas/ach2043-2013/ep1")
arqglc = 'inp-glc.txt'
qts = scan(arqglc, what=integer(), nlines=1)
qts
qts = scan(arqglc, what=integer(), nlines=1)
V = scan(arqglc, what=character(), nlines=1, skip=1)
v
V
qts = scan(arqglc, what=integer(), nlines=1)
# lista de variaveis
vlist = scan(arqglc, what=character(), nlines=1, skip=1)
# lista de terminais
tlist = scan(arqglc, what=character(), nlines=1, skip=2)
rlist = scan(arqglc, what=character(), nlines=qts[3], skip=3, quiet=TRUE)
rlist
rlist = scan(arqglc, what=character(), sep='\n',
nlines=qts[3], skip=3, quiet=TRUE)
rlist
unlist(str_split(rlist,' '))
str_split(rlist,' ')
??split
?paste
strsplit(rlist,' ')
strsplit(rlist[1],' ')
unlist(strsplit(rlist[1],' '))
# matriz de regras
MR = matriz(0, nrow=qtreg, ncol=3)
for (i in qtreg) {
vaux = unlist(strsplit(rlist[i], ' '))[-2]
MR[i, 1:length(vaux)] = vaux
}
qts = scan(arqglc, what=integer(), nlines=1, quiet=TRUE)
qtvar = qts[1]
qtter = qts[2]
qrreg = qts[3]
qts = scan(arqglc, what=integer(), nlines=1, quiet=TRUE)
qtvar = qts[1]
qtter = qts[2]
qrreg = qts[3]
# lista de variaveis
vlist = scan(arqglc, what=character(), nlines=1, skip=1, quiet=TRUE)
# lista de terminais
tlist = scan(arqglc, what=character(), nlines=1, skip=2, quiet=TRUE)
# lista de regras
rlist = scan(arqglc, what=character(), sep='\n',
nlines=qtreg, skip=3, quiet=TRUE)
# matriz de regras
MR = matriz(0, nrow=qtreg, ncol=3)
for (i in qtreg) {
vaux = unlist(strsplit(rlist[i], ' '))[-2]
MR[i, 1:length(vaux)] = vaux
}
qts = scan(arqglc, what=integer(), nlines=1, quiet=TRUE)
qtvar = qts[1]
qtter = qts[2]
qtreg = qts[3]
# lista de variaveis
vlist = scan(arqglc, what=character(), nlines=1, skip=1, quiet=TRUE)
# lista de terminais
tlist = scan(arqglc, what=character(), nlines=1, skip=2, quiet=TRUE)
# lista de regras
rlist = scan(arqglc, what=character(), sep='\n',
nlines=qtreg, skip=3, quiet=TRUE)
# matriz de regras
MR = matrix(0, nrow=qtreg, ncol=3)
for (i in qtreg) {
vaux = unlist(strsplit(rlist[i], ' '))[-2]
MR[i, 1:length(vaux)] = vaux
}
MR
arqglc = 'inp-glc.txt'
#
#  g: num variaveis
#  t: num terminais
#  s: num regras substituicao
#
qts = scan(arqglc, what=integer(), nlines=1, quiet=TRUE)
qtvar = qts[1]
qtter = qts[2]
qtreg = qts[3]
# lista de variaveis
vlist = scan(arqglc, what=character(), nlines=1, skip=1, quiet=TRUE)
# lista de terminais
tlist = scan(arqglc, what=character(), nlines=1, skip=2, quiet=TRUE)
# lista de regras
rlist = scan(arqglc, what=character(), sep='\n',
nlines=qtreg, skip=3, quiet=TRUE)
# matriz de regras
MR = matrix(0, nrow=qtreg, ncol=3)
for (i in 1:qtreg) {
vaux = unlist(strsplit(rlist[i], ' '))[-2]
MR[i, 1:length(vaux)] = vaux
}
MR
?array
qtcad = scan(arqcad, what=integer(), nlines=1, quiet=TRUE)
arqcad = 'inp-cadeias.txt'
qtcad = scan(arqcad, what=integer(), nlines=1, quiet=TRUE)
idc=1
cadeia = scan(arqcad, what=character(), sep=' ',
nlines=1, skip=idc, quiet=TRUE)
cadeia
idc=1
szcad = length(cadeia)
qtv = matrix(0, nrow=szcad, ncol=szcad)
MV = array(0, dim=c(szcad, szcad, qtvar))
MV
?for
()
??for
()
help.search('for')
qtter
it=1
termatu = tlist[it]
idxt = which(cadeia==termatu)
idxt
if (length(idxt)==0) { # cadeia nao contem o terminal atual
next
}
idxreg = which(MR[,2]==termatu)
idxreg
qtregter = length(idxreg)
diag(qtv) = length(idxreg)
qtv
qtv = matrix(0, nrow=szcad, ncol=szcad)
diag(qtv)[idxt] = length(idxreg)
qtv
colnames(qtv)=cadeia
rownames(qtv)=cadeia
qtv
MV[idxt, idxt, 1:length] = MR[idxreg,1]
MV[idxt,idxt]
MV[idxt,idxt,]
for (j in 1:qtregter) {
MV[idxt, idxt, j] = MR[idxreg[j],1]
}
MV
diag(MV)
setwd("/media/OS/marcelo/each/disciplinas/ach2043-2013/ep1")
arqglc = 'inp-glc.txt'
arqcad = 'inp-cadeias.txt'
#
#  g: num variaveis
#  t: num terminais
#  s: num regras substituicao
#
qts = scan(arqglc, what=integer(), nlines=1, quiet=TRUE)
qtvar = qts[1]
qtter = qts[2]
qtreg = qts[3]
# lista de variaveis
vlist = scan(arqglc, what=character(), nlines=1, skip=1, quiet=TRUE)
# lista de terminais
tlist = scan(arqglc, what=character(), nlines=1, skip=2, quiet=TRUE)
# lista de regras
rlist = scan(arqglc, what=character(), sep='\n',
nlines=qtreg, skip=3, quiet=TRUE)
# matriz de regras
MR = matrix(0, nrow=qtreg, ncol=3)
for (i in 1:qtreg) {
vaux = unlist(strsplit(rlist[i], ' '))[-2]
MR[i, 1:length(vaux)] = vaux
}
# lista de cadeias
qtcad = scan(arqcad, what=integer(), nlines=1, quiet=TRUE)
# Processamento de cada cadeia
Aceitacoes = rep(0, qtcad)
idc=1
cadeia = scan(arqcad, what=character(), sep=' ',
nlines=1, skip=idc, quiet=TRUE)
szcad = length(cadeia)
# Cadeia vazia:
if (cadeia=="&") {
if (length(which(MR[,2]=="&"))>0) {
Aceitacoes[idc] = 1
}
next
}
MV = array(0, dim=c(szcad, szcad, qtvar))
qtv = matrix(0, nrow=szcad, ncol=szcad)
colnames(qtv)=cadeia
rownames(qtv)=cadeia
it = 1
termatu = tlist[it]
idxt = which(cadeia==termatu)
if (length(idxt)==0) { # cadeia nao contem o terminal atual
next
}
# procura regras em que o lado direito eh o terminal atual
idxreg = which(MR[,2]==termatu)
qtregter = length(idxreg)
if (qtregter>0) {
diag(qtv)[idxt] = length(idxreg)
for (j in 1:qtregter) {
MV[idxt, idxt, j] = MR[idxreg[j],1]
}
}
MV
idxreg
MR[idxreg]
MR[idxreg,1]
MR
tv
qtv
MV = array(0, dim=c(szcad, szcad, qtvar))
qtv = matrix(0, nrow=szcad, ncol=szcad)
colnames(qtv)=cadeia
rownames(qtv)=cadeia
for (it in 1:qtter) {
termatu = tlist[it]
idxt = which(cadeia==termatu)
if (length(idxt)==0) { # cadeia nao contem o terminal atual
next
}
# procura regras em que o lado direito eh o terminal atual
idxreg = which(MR[,2]==termatu)
qtregter = length(idxreg)
if (qtregter>0) {
diag(qtv)[idxt] = length(idxreg)
for (j in 1:qtregter) {
for (k in idxt) {
M[k,k,j] = match(MR[idxreg[j],1], vlist)
}
}
}
}
MV = array(0, dim=c(szcad, szcad, qtvar))
qtv = matrix(0, nrow=szcad, ncol=szcad)
colnames(qtv)=cadeia
rownames(qtv)=cadeia
#
#  Processamento
#
for (it in 1:qtter) {
termatu = tlist[it]
idxt = which(cadeia==termatu)
if (length(idxt)==0) { # cadeia nao contem o terminal atual
next
}
# procura regras em que o lado direito eh o terminal atual
idxreg = which(MR[,2]==termatu)
qtregter = length(idxreg)
if (qtregter>0) {
diag(qtv)[idxt] = length(idxreg)
for (j in 1:qtregter) {
for (k in idxt) {
MV[k,k,j] = match(MR[idxreg[j],1], vlist)
}
}
}
}
MV
MV = array(0, dim=c(szcad, szcad, qtvar))
qtv = matrix(0, nrow=szcad, ncol=szcad)
colnames(qtv)=cadeia
rownames(qtv)=cadeia
#
#  Processamento
#
for (it in 1:qtter) {
termatu = tlist[it]
idxt = which(cadeia==termatu)
if (length(idxt)==0) { # cadeia nao contem o terminal atual
next
}
# procura regras em que o lado direito eh o terminal atual
idxreg = which(MR[,2]==termatu)
qtregter = length(idxreg)
if (qtregter>0) {
diag(qtv)[idxt] = length(idxreg)
for (j in 1:qtregter) {
for (k in idxt) {
MV[k,k,match(MR[idxreg[j],1], vlist)] = 1
}
}
}
}
MV
for (i in 1:0) {}
for (i in 1:0) {
print(i) }
for (l in 2:szcad) {
for (i in 1:(szcad-l+1)) {
j = i+l-1
for (k in i:(j-1)) {
for (p1 in 1:qtvar) {
for (p2 in 1:qtvar) {
if (MV[i,k,p1]==1 & MV[k+1,j,p2]==1) {
idxreg = union(intersection(which(MR[,2]==vlist[p1]), which(MR[,3]==vlist[p2])),
intersection(which(MR[,3]==vlist[p1]), which(MR[,2]==vlist[p2])))
qtregvar = length(idxreg)
if (qtregvar>0) {
for (q in 1:qtregvar) {
MV[i,j,match(MR[idreg[q], 1], vlist)] = 1
}
}
}
}
}
}
}
}
# Aloca as estruturas de dados principais:
# MV: matriz binaria indicando quais variaveis estao ativas em cada posicao
# qtv: Quantidade de variaveis em cada posicao da matriz
MV = array(0, dim=c(szcad, szcad, qtvar))
qtv = matrix(0, nrow=szcad, ncol=szcad)
colnames(qtv)=cadeia
rownames(qtv)=cadeia
#
#  Processamento de cadeias nao vazias
#
#
# Preenchimento da diagonal principal da tabela
#
for (it in 1:qtter) {
termatu = tlist[it]
idxt = which(cadeia==termatu)
if (length(idxt)==0) { # cadeia nao contem o terminal atual
next
}
# procura regras em que o lado direito eh o terminal atual
idxreg = which(MR[,2]==termatu)
qtregter = length(idxreg)
if (qtregter>0) {  # se encontrou as regras, insere variaveis
diag(qtv)[idxt] = length(idxreg)
for (j in 1:qtregter) {
for (k in idxt) {
MV[k,k,match(MR[idxreg[j],1], vlist)] = 1  # ativa flag
}
}
}
}
#
# Preenchimento das demais posicoes
#
for (l in 2:szcad) {
for (i in 1:(szcad-l+1)) {
j = i+l-1
for (k in i:(j-1)) {
for (p1 in 1:qtvar) {
for (p2 in 1:qtvar) {
if (MV[i,k,p1]==1 & MV[k+1,j,p2]==1) {
idxreg = union(intersect(which(MR[,2]==vlist[p1]), which(MR[,3]==vlist[p2])),
intersect(which(MR[,3]==vlist[p1]), which(MR[,2]==vlist[p2])))
qtregvar = length(idxreg)
if (qtregvar>0) {
for (q in 1:qtregvar) {
MV[i,j,match(MR[idreg[q], 1], vlist)] = 1
}
}
}
}
}
}
}
}
for (l in 2:szcad) {
for (i in 1:(szcad-l+1)) {
j = i+l-1
for (k in i:(j-1)) {
for (p1 in 1:qtvar) {
for (p2 in 1:qtvar) {
if (MV[i,k,p1]==1 & MV[k+1,j,p2]==1) {
idxreg = union(intersect(which(MR[,2]==vlist[p1]), which(MR[,3]==vlist[p2])),
intersect(which(MR[,3]==vlist[p1]), which(MR[,2]==vlist[p2])))
qtregvar = length(idxreg)
if (qtregvar>0) {
for (q in 1:qtregvar) {
MV[i,j,match(MR[idxreg[q], 1], vlist)] = 1
}
}
}
}
}
}
}
}
MV
# Aloca as estruturas de dados principais:
# MV: matriz binaria indicando quais variaveis estao ativas em cada posicao
# qtv: Quantidade de variaveis em cada posicao da matriz
MV = array(0, dim=c(szcad, szcad, qtvar))
qtv = matrix(0, nrow=szcad, ncol=szcad)
colnames(qtv)=cadeia
rownames(qtv)=cadeia
#
#  Processamento de cadeias nao vazias
#
#
# Preenchimento da diagonal principal da tabela
#
for (it in 1:qtter) {
termatu = tlist[it]
idxt = which(cadeia==termatu)
if (length(idxt)==0) { # cadeia nao contem o terminal atual
next
}
# procura regras em que o lado direito eh o terminal atual
idxreg = which(MR[,2]==termatu)
qtregter = length(idxreg)
if (qtregter>0) {  # se encontrou as regras, insere variaveis
diag(qtv)[idxt] = length(idxreg)
for (j in 1:qtregter) {
for (k in idxt) {
MV[k,k,match(MR[idxreg[j],1], vlist)] = 1  # ativa flag
}
}
}
}
#
# Preenchimento das demais posicoes
#
for (l in 2:szcad) {
for (i in 1:(szcad-l+1)) {
j = i+l-1
for (k in i:(j-1)) {
for (p1 in 1:qtvar) {
for (p2 in 1:qtvar) {
if (MV[i,k,p1]==1 & MV[k+1,j,p2]==1) {
idxreg = intersect(which(MR[,2]==vlist[p1]), which(MR[,3]==vlist[p2]))
qtregvar = length(idxreg)
if (qtregvar>0) {
for (q in 1:qtregvar) {
MV[i,j,match(MR[idxreg[q], 1], vlist)] = 1
}
}
}
}
}
}
}
}
MV
?cat
arqglc = 'inp-glc.txt'
arqcad = 'inp-cadeias.txt'
arqst  = 'out-status.txt'
arqtab = 'out-tabela.txt'
?cat
cat('',arqtab,append=FALSE)
cat('',file=arqtab,append=FALSE)
paste (Aceitacoes, file=arqst, append=FALSE)
Aceitacoes
cat(Aceitacoes, file=arqst, append=FALSE)
source('/media/OS/marcelo/each/disciplinas/ach2043-2013/ep1/glc.r', echo=TRUE)
source('/media/OS/marcelo/each/disciplinas/ach2043-2013/ep1/glc.r', echo=TRUE)
source('/media/OS/marcelo/each/disciplinas/ach2043-2013/ep1/glc.r', echo=TRUE)
source('/media/OS/marcelo/each/disciplinas/ach2043-2013/ep1/glc.r', echo=TRUE)
source('/media/OS/marcelo/each/disciplinas/ach2043-2013/ep1/glc.r', echo=TRUE)
lista
source('/media/OS/marcelo/each/disciplinas/ach2043-2013/ep1/glc.r', echo=TRUE)
source('/media/OS/marcelo/each/disciplinas/ach2043-2013/ep1/glc.r', echo=TRUE)
source('/media/OS/marcelo/each/disciplinas/ach2043-2013/ep1/glc.r', echo=TRUE)
setwd("/media/OS/marcelo/each/disciplinas/ach2043-2013/ep1")
setwd("/media/OS/marcelo/each/disciplinas/ach2043-2013/ep1/exemplo1")
source('/media/OS/marcelo/each/disciplinas/ach2043-2013/ep1/glc.r', echo=TRUE)
